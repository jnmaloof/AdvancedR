---
title: "Chapter 8"
author: "Julin Maloof"
date: "2022-11-01"
output: 
  html_document: 
    keep_md: yes
---




```r
library(tidyverse)
```

```
## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
## ✔ ggplot2 3.3.6      ✔ purrr   0.3.4 
## ✔ tibble  3.1.8      ✔ dplyr   1.0.10
## ✔ tidyr   1.2.0      ✔ stringr 1.4.1 
## ✔ readr   2.1.2      ✔ forcats 0.5.2 
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
```

```r
library(rlang)
```

```
## 
## Attaching package: 'rlang'
## 
## The following objects are masked from 'package:purrr':
## 
##     %@%, as_function, flatten, flatten_chr, flatten_dbl, flatten_int,
##     flatten_lgl, flatten_raw, invoke, splice
```

## 8.2.4 Exercises

### 1. Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.


```r
file.remove2 <- function(...) {
  for(f in list(...)) 
      if(!file.exists(f)) abort(paste0("File '", f, "' does not exist!"))
  file.remove(...)
}


file.create("chapter8testfile.txt")
```

```
## [1] TRUE
```

```r
file.remove2("chapter8testfile.txt")
```

```
## [1] TRUE
```

```r
file.create("chapter8testfile2.txt")
```

```
## [1] TRUE
```

```r
file.remove2("chapter8testfile2.txt", "a")
```

```
## Error in `file.remove2()`:
## ! File 'a' does not exist!
```

```r
file.remove2("chapter8testfile2.txt")
```

```
## [1] TRUE
```


### 2. What does the appendLF argument to message() do? How is it related to cat()

_adds a newline.  cat() does not do this_

## 8.4.5 Exercises

### 1. What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.


```r
str(catch_cnd(stop("An error")))
```

```
## List of 2
##  $ message: chr "An error"
##  $ call   : language force(expr)
##  - attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
```

```r
str(catch_cnd(abort("An error")))
```

```
## List of 4
##  $ message: chr "An error"
##  $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame':	9 obs. of  6 variables:
##   ..$ call       :List of 9
##   .. ..$ : language str(catch_cnd(abort("An error")))
##   .. ..$ : language catch_cnd(abort("An error"))
##   .. ..$ : language eval_bare(rlang::expr(tryCatch(!!!handlers, {     force(expr) ...
##   .. ..$ : language tryCatch(condition = `<fn>`, {     force(expr) ...
##   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
##   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
##   .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
##   .. ..$ : language force(expr)
##   .. ..$ : language abort("An error")
##   ..$ parent     : int [1:9] 0 0 2 2 4 5 6 2 0
##   ..$ visible    : logi [1:9] FALSE FALSE FALSE FALSE FALSE FALSE ...
##   ..$ namespace  : chr [1:9] "utils" "rlang" "rlang" "base" ...
##   ..$ scope      : chr [1:9] "::" "::" "::" "::" ...
##   ..$ error_frame: logi [1:9] FALSE FALSE FALSE FALSE FALSE FALSE ...
##   ..- attr(*, "version")= int 2
##  $ parent : NULL
##  $ call   : NULL
##  - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"
```
_`abort` shows the backtrace, assigns a class, and has additional data_ 

### 2. Predict the results of evaluating the following code


```r
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!")) # will produce an error message "error" (but not "!")
```

```
## [1] "error"
```

```r
show_condition(10) # will return NULL
```

```
## NULL
```

```r
show_condition(warning("?!")) # will return "warning" and then stop because of tryCatch
```

```
## [1] "warning"
```

```r
show_condition({
  10
  message("?")
  warning("?!")
}) #will return "message" and then stop because of tryCatch
```

```
## [1] "message"
```


### 3. Explain the results of running this code:


```r
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

```
## b
```

```
## a
```

```
## b
```

```
## c
```

```r
#> b
#> a
#> b
#> c
```

_message(c) bubbles up to message("a"); execution of that code causes "b" to get printed.  Then "a" gets printed, and then "c" continues to bubble up up to message("b") and prints b (second time); then finally "c" is printed._
 
### 4. Read the source code for catch_cnd() and explain how it works.

### 5. How could you rewrite show_condition() to use a single handler?


```r
show_condition <- function(code) {
  c <- catch_cnd(
    {
      code
    }
  ) 
  if (!is.null(c)) class(c)[2] else NULL
}

show_condition(stop("!")) # will produce an error message "error" (but not "!")
```

```
## [1] "error"
```

```r
show_condition(10) # will return NULL
```

```
## NULL
```

```r
show_condition(warning("?!")) # will return "warning" 
```

```
## [1] "warning"
```

```r
show_condition({
  10
  message("?")
  warning("?!")
}) #will return "message" and then stop
```

```
## [1] "message"
```

