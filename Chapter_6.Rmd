---
title: "Chapter6"
author: "Julin Maloof"
date: "2022-10-08"
output: 
  html_document: 
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```

## Quiz

1. What are the three components of a function?

_name, arguments, code?_

2. What does the following code return?

```{r}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```
_11.  Note that the initial assignment of x <- 10 is just a distractor.  _


3. How would you usually write this code?

```{r}
`+`(1, `*`(2, 3))
```

```{r}
1 + 2*3
```


4. How could you make this call easier to read?

mean(, TRUE, x = c(1:10, NA))

```{r}
mean(, TRUE, x = c(1:10, NA))
```

```{r}
mean(c(1:10, NA), na.rm=TRUE)
```


5. Does the following code throw an error when executed? Why or why not?

```{r}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

I guessed "no" and I was correct.  Because "b" is not evaluated

6. What is an infix function? How do you write it? What’s a replacement function? How do you write it?

??

7. How do you ensure that cleanup action occurs regardless of how a function exits?

??

## Exercises 6.2.5

1. Given a name, like "mean", match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?

_I don't even know what this is asking._

2. It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r}
function(x) 3()
#> function(x) 3()
(function(x) 3)()
#> [1] 3
```

_Took me a minute to understand this at all.  But the function is a function that will return 3, no matter what is input.  The second veresion is what works but I do not understand the syntax_


3. A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

4. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

```{r}
f <- function(x) x^2

typeof(f)

is.function(f)

is.primitive(f)

is.primitive(sum)
```


5. This code makes a list of all functions in the base package.

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

Use it to answer the following questions:

6. Which base function has the most arguments?

```{r}
fun.args <- sapply(funs, function(x) length(formals(x))) 

names(funs)[which.max(fun.args)] 

formals(scan)
```


7. How many base functions have no arguments? What’s special about those functions?

```{r}
names(funs)[fun.args==0]

sapply(funs[fun.args==0], is.primitive)
```

_many are primitives, the rest return something without input_


8. How could you adapt the code to find all primitive functions?

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
primfuns <- Filter(is.primitive, objs)
```

9. What are the three important components of a function?

_Arguments, body, environment_

10. When does printing a function not show the environment it was created in?

_when the function exists in the global environment_

```{r}
sum
f
stats::aggregate
```

## 6.4.5 Exercises

1. What does the following code return? Why? Describe how each of the three c’s is interpreted.

```{r}
c <- 10
c(c = c)
```

_I predict 10.  Answer is c=10.  The first "c" is an object name, a reference to the value 10.  The second c calls the `c()` function.  The third c is used as a name for the first element in the vector that c is creating, and the final c refers to the "c" object._

2. What are the four principles that govern how R looks for values?

_masking, fresh start, functions separate from variables, dynamic lookup_

3. What does the following function return? Make a prediction before running the code yourself.

```{r}
f <- function(x) { # this is the f that gets called
  # x = 10
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1 
  }
  f(x) * 2 # calls the first nested function, which calls the innermost function.  So 202
}
f(10)
```

## 6.5.4 Exercises

1. What important property of && makes x_ok() work?

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
#> [1] FALSE
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE
```

with `&&` it doesn't keep evaluating once a FALSE is reached

What is different with this code? Why is this behaviour undesirable here?

```{r}

x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
#> logical(0)
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE FALSE FALSE
```

`&` is going to evaluate all code.  We want a single T or F and that is not what is being returned here.

2. What does this function return? Why? Which principle does it illustrate?

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

_should return 100 and illustrates that arguments can be assigned internal in the function.  I hate this_


3. What does this function return? Why? Which principle does it illustrate?

```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()
y
```
_I don't get it_

4. In hist(), the default value of xlim is range(breaks), the default value for breaks is "Sturges", and

```{r}
range("Sturges")
#> [1] "Sturges" "Sturges"
```


Explain how hist() works to get a correct xlim value.

_it is using the Sturges function_

5. Explain why this function works. Why is it confusing?

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
#> [1] "2021-02-21 19:22:36 UTC"
```

_because x is evaluated inside the function and a new stop function has been defined inside of the show_time function_

6. How many arguments are required when calling library()?

```{r}
args(library)
#library()
```
Zero arguments, but not sure how to figure this out.
